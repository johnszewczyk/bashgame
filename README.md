# bashgame
<br>
<p>...is a text/ console game written in Bash 5+. A player-controlled cursor is pursued by an AI enemy across a tile-based gameboard. Players make their way toward the exit tile while taking cover from the enemy on "safe" tiles.</p>
<br>

## Features
<ul>
  <li>Emoji graphics</li>
  <li>Collision detection</li>
  <li>Scaleable game board size</li>
</ul>

<br>

## Map & Display

<p>A square map of customisable size is stored as an array of arrays. Each array[init] is assigned a tile type by random number generation. A third reference array allows lookup of an index by keys. Thus, each tile is an array with keys [init] for initial tile value and [occp] to designate an occupation by a player, enemy, or item.</p>

#### Tile Types

```bash
declare TILE_TREE="üå≥"    # blocked tile
declare TILE_WOOD="üå≤"    # empty tile
declare TILE_CABIN="üè†"   # safe tile
declare TILE_WINNER="üöî"  # exit tile
declare TILE_PLAYER="üèÉ"  # player
declare TILE_ENEMY="üî™"   # enemy
```

<br>
<p>After tile generation, functions to `find all tiles of a type` and `replace adjacent tiles` are used to expand tile areas beyond 1x1.</p>
<br>

## Controls & Movement
<br>

```bash
# wait for any input key
  read -rsn1 -t${GAMESPEED} keystroke

  [[ $keystroke == "w" ]] && ((y = y + 1)) # directional movement north
  [[ $keystroke == "a" ]] && ((x = x - 1)) # directional movement west
  [[ $keystroke == "s" ]] && ((y = y - 1)) # directional movement south
  [[ $keystroke == "d" ]] && ((x = x + 1)) # directional movement east
```
<br>
<p>
Player movement is modeled using keystrokes to increment a cursor across an array. Later, it is adapted to add +1 for horizontal movement and +10 for vertical movement, for example, in a 10x10 map. 
</p>

<p>
The enemy cursor is allowed to move faster and diagonally, to move each turn <b>and</b> each time the player moves, and to teleport in the event of becoming stuck on something.
</p>

<p>
  Tile types are generated by percentage using $RANDOM.
</p>
<br>

Database & Framebuffer

```bash
    # update player location in database
    player_tile_id=$(printf "p%02d%02d" "$x" "$y") # locate tile in database
    player_target_tile="${player_tile_id}[init]"   # store tile init value in [init]
    eval "${player_tile_id}[occp]=$TILE_PLAYER"    # set tile val to player

    # update player location in framebuffer
    player_tile_xy=${player_tile_id:1}              # get only the coordinates
    player_index=${pixelDictonary[$player_tile_xy]} # get the index using coordinates
    framebuffer[player_index]="$TILE_PLAYER"        # update framebuffer
```

<p>Once the map is generated, a second array is created to use as a framebuffer (the 'pixel' data to draw). Referencing the inital array, which serves as a database, is too slow to utilize as a framebuffer. The second array, which is updated only incrementally, is drawn repeatedly. (More to come.)</p>

<br>

## Future

<ul>

  <li>
    Method to display only a small area of the map.</li>
  <li>
    Collectable items & power-ups.
  </li>
  <li>
    Multiple enemies
  </li>
</ul>
