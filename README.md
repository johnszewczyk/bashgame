# bashgame
<br>
<p>...is a text/ console game written in Bash 5+. A player-controlled cursor is pursued by an AI enemy across a tile-based gameboard. Players make their way toward the exit tile while taking cover from the enemy on "safe" tiles.</p>
<br>

<h2>Features</h2>
<ul>
  <li>Emoji graphics</li>
  <li>Collision detection</li>
  <li>Scaleable game board size</li>
</ul>

<br>

<h2>Map & Display</h2>

<p>A square map of customisable size is stored as an array. Each index is assigned a tile type by random number generation. Tile outcomes are hard-coded and stored in a tile database array. </p>

<h3>Tile Types</h3>

<ul>
  <li>Stanard passable tile</li>
  <li>Impassible tile</li>
  <li>Safe tile; not passable by enemy</li>
  <li>Exit/ win tile</li>
</ul>
<br>
<p>After tile generation, functions to <i>find all tiles of a type</i> and <i>replace adjacent tiles</i> are used to expand tile areas beyond 1x1.</p>
<br>
<h3>Controls & Movement</h3>

<p>Player movement is modeled using keystrokes to increment a cursor across an array, adding +1 for horizontal movement and +10 for horizontal movement, for example, in a 10x10 map. The Bash method "read -rsn1 -t" captures keystrokes which are processed and approved or denied to enable collision/ disallow movement. The enemy cursor is allowed to move faster and diagonally, to move each turn <b>and</b> each time the player moves, and to teleport in the event of becoming stuck on something.</p>

<p>
  Tile types are generated by percentage using $RANDOM.
</p>
<br>

<p>Once the map is generated, a second array is created to use as a framebuffer (the 'pixel' data to draw). Referencing the inital array, which serves as a database, is too slow to utilize as a framebuffer. The second array, which is updated only incrementally, is drawn repeatedly. (More to come.)</p>

<br>

<h2>Future</h2>

<ul>

  <li>
    Method to display only a small area of the map.</li>
  <li>
    Collectable items & power-ups.
  </li>
  <li>
    Multiple enemies
  </li>
</ul>
